# گزارش آزمایش اول درس مهندسی نرم افزار
## اعضای گروه:
+ سید محمدمهدی حاتمی 98109561
+ پیمان حاجی محمد 98170776
## شرح آزمایش
در ابتدا ما یک مخزن عمومی گیت ایجاد کردیم و فایل های readme و gitignore را برای فایل های پایتونی و نرم افزار pycharm اضافه کردیم.
![Screenshot 2023-10-28 044349](https://github.com/peyman79/SE-Lab1/assets/61017890/c36c4079-a10a-4a4c-a98f-0cfedaa33b92)

سپس برای برنچ main سیاست عدم امکان مرج برنچی دیگر بدون ایجاد pull request را به آن اضافه کردیم
![Screenshot 2023-10-28 044707](https://github.com/peyman79/SE-Lab1/assets/61017890/4dd4b535-239c-423d-a902-b754b50d2ec1)
![Screenshot 2023-10-28 045658](https://github.com/peyman79/SE-Lab1/assets/61017890/2a72bbdc-ece2-4e00-85e9-8b99b4560ff3)

در ادامه شروع به پیاده سازی پروژه انتخاب واحد دانشجویی پرداختیم. بدین صورت که ما یک برنچ develop ایجاد کردیم که برنچ های فیچر ما از آن برنچ منبع گرفته و در نهایت در همان برنچ ادغام می شوند. همچنین در هر بار انتشار پروژه، ابتدا برنچ develop را با برنچ main مرج کرده سپس نسخه را برای انتشار آماده می کنیم. یک نمونه از برنچ های فیچر که pull request آن زده شده و منتظر تایید برای ادغام شدن با برنچ develop می باشد را در تصویر زیر مشاهده می نمایید:
![Screenshot 2023-10-28 115520](https://github.com/peyman79/SE-Lab1/assets/61017890/6b98ceff-198c-4d6b-9c41-fa1f3c04c61c)
![Screenshot 2023-10-28 115557](https://github.com/peyman79/SE-Lab1/assets/61017890/5f8ed96c-a7b7-4a52-b1fb-1f363547c135)
![Screenshot 2023-10-28 115615](https://github.com/peyman79/SE-Lab1/assets/61017890/f7968963-06c8-44e8-b330-3fe9eda3cc6d)

در ادامه ی روند پروژه با تکرار روند بالا فیچر های جدیدی از قبیل ساختن درس، برداشتن و حذف کردن واحد و ... به نرم افزار خود اضافه میکنیم و آن را در برنچ develop مرج می کنیم. 
![Screenshot from 2023-10-29 14-33-48](https://github.com/peyman79/SE-Lab1/assets/62210297/bf0cc274-1597-46bc-8bd4-f8b5cc30e0e3)
سپس برای آپدیت شدن گزارش در کنار کد، برنچ گزارش را در برنچ develop مرج میکنیم. سپس برای نوشتن ادامه ی گزارش و برای این که در کنار کد باشد برنچ develop را نیز در برنچ گزارش مرج میکنیم. 


## پرسش ها
1. پوشه git یک پوشه hidden بوده که حاوی اطلاعاتی از جمله تاریخچه کامیت ها، برنچ ها، کانفیگ ها (مانند اطلاعات ایمیل و اکانت متصل به مخزن گیت) و... می باشد. این پوشه با دستور git init در ترمینال git bash ساخته می شود.
2. در این دو مفهوم، اتمیک بودن بدین معناست که تغییرات موجود در یک کامیت یا برنچ مشخص بایستی مرتبط با یک هدف خاص باشد. بعنوان مثال یک کامیتی که شامل رفع چندین باگ و افزودن فیچر باشد نمی تواند یک کامیت اتمیک باشد. به صورت معادل یک برنچ که شامل افزودن چندین ویژگی غیر مرتبط به هم در خود میشود نمیتواند برنچ اتمیک شناخته شود
3. دستور fetch اطلاعات و تغییرات جدید از یک ریپازیتوری را دریافت می‌کند، اما تغییرات را در شاخه‌های کاری محلی اعمال نمی‌کند. دستور merge برای ادغام تغییرات از یک شاخه به شاخه دیگر استفاده می‌شود. دستور pull ترکیبی از دستورهای fetch و merge است. ابتدا تغییرات جدید را از ریپازیتوری اصلی با استفاده از fetch دریافت می‌کند و سپس تغییرات را با شاخه کاری محلی merge می‌کند.دستور rebase برای اعمال تغییرات از یک شاخه به شاخه دیگر استفاده می‌شود، اما به جای ادغام تغییرات، تغییرات را به شاخه مقصد اعمال می‌کند. با استفاده از rebase، تاریخچه commit ها در شاخه مقصد تغییر می‌کند و تغییرات جدید به صورت مستقیم بر روی شاخه مقصد اعمال می‌شوند. دستور cherry-pick برای انتخاب و اعمال یک commit خاص از یک شاخه به شاخه دیگر استفاده می‌شود. با استفاده از این دستور، می‌توان یک commit خاص را از یک شاخه را انتخاب کرده و بدون اعمال سایر تغییرات شاخه اصلی، آن را در شاخه مقصد اعمال کرد. در زیر نمونه تصویری این دستورات قابل مشاهده اند:
![image](https://github.com/peyman79/SE-Lab1/assets/61017890/289fea74-89c7-4d7d-96f4-96f4bf80ff8c)
![image](https://github.com/peyman79/SE-Lab1/assets/61017890/db0408b9-af1d-4acd-a011-e9a05e3d389d)
![image](https://github.com/peyman79/SE-Lab1/assets/61017890/2eb14c86-6296-40c6-a721-d625553384c5)

4. دستور restore برای خارج کردن تغییرات از محیط staging یا پاک کردن آن‌ها از working tree استفاده می‌شود. بر خلاف دو دستور دیگر، این دستور به تنهایی تاثیری بر روی کامیت ها یا برنچ های ساخته شده ندارد و فقط محیط های خارج از کامیت ها را تغییر می دهد. 
![image](https://github.com/peyman79/SE-Lab1/assets/62210297/4aa40fd2-0e94-4aa5-9367-c6701d7e27a2)
   
دستور reset برای تغییر دادن محل یک برنچ استفاده می شود. این دستور تغییری در خود کامیت ها ایجاد نمی کند، بلکه برنچ انتخاب شده را به کامیت انتخاب شده ای می برد. یکی از استفاده های این دستور برای زمانی ست که کامیت هایی روی برنچ اشتباهی انجام شده باشد و بخواهیم برنچ جدیدی برای این تغییرات ایجاد کنیم و برنچ قبلی را به پیش از این کامیت ها منتقل کنیم. این دستور بر خلاف دستور revert به تنهایی کامیت جدیدی ایجاد نمی کند و تنها برنچ را جا به جا می کند. 
![image](https://github.com/peyman79/SE-Lab1/assets/62210297/c45afe90-d68a-44e2-a37b-f67fd62dbac0)

دستور revert برای undo کردن تغییرات یک کامیت استفاده می شود. در استفاده از این دستور یک کامیت انتخاب شده و در قالب کامیت جدیدی، تغییرات پیاده سازی شده در آن کامیت به حالت قبل خود برمیگردند. این دستور کامیت جدیدی ایجاد می کند و برنچ فعلی را نیز به روی آن حرکت می دهد. 
![image](https://github.com/peyman79/SE-Lab1/assets/62210297/48ca8c2b-d7a9-485d-ac8f-0fdd62011560)

[منبع](https://blog.git-init.com/how-to-undo-changes-in-git-using-reset-revert-and-restore/) 

5. محیط staging یکی از چند محیط تشکیل شده در گیت است. این محیط فایل هایی را مشخص می کند که تغییر کرده اند ولی هنوز در کامیتی قرار نگرفته اند و اگر الان کامیتی انجام دهیم، این تغییرات در آن کامیت قرار میگیرند. با استفاده از دستور git add <file> میتوان یک فایل را به این محیط اضافه کرد. همچنین دستور git status علاوه بر اطلاعات همیشگی، نمایی از وضعیت این محیط نیز نمایش می دهد. یکی از کاربرد های وجود این محیط تقسیم کردن تغییرات انجام شده در کامیت های متفاوت است.
دستور stash تمام تغییرات کامیت نشده اعم از فایل های داخل و خارج staging را برداشته و در یک استک ذخیره می کند. با این کار وضعیت فایل های مورد نظر به آخرین کامیت بر میگردد و تغییرات انجام شده برای استفاده ی دوباره ذخیره می شوند. در آینده میتوان با استفاده از دستور git stash pop این تغییرات از استک حذف شده و مجددا به working tree ما اعمال می شوند. البته اگر بخواهیم که این تغییرات اعمال شده ولی از استک حذف نشوند، میتوان از دستور git stash apply استفاده کرد.

6. مفهوم snappshot شبیه به عکس گرفتن از یک لحظه ی پروژه است. در واقع در یک snappshot از یک پروژه، وضعیت تک تک اجزای آن در آن لحظه مشخص است. هر کامیت گیت یک snappshot از پروژه ی ما ارائه میکند، ولی این کار را از طریق ذخیره سازی تمام فایل های آن لحظه انجام نمی دهد؛ بلکه به کامیت قبلی خود به عنوان مرجع اشاره کرده و تغییرات رخ داده نسبت به آن را ذخیره می کند. با این سیستم با شروع از یک کامیت و طی کردن parent های آن تا رسیدن به کامیت base (کامیتی که parent ندارد.) میتوان snappshot پروژه در آن لحظه را بازسازی کرد. 



